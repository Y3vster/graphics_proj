// Generated by CoffeeScript 1.11.1

/*jslint browser: true */


/*global THREE, window */

(function() {
  "use strict";
  var $, camXY, camera, cube, geometry, init, material, mouseXY, onMove, onWindResize, render, renderer, scene, stats, updateCameraPosn, windCenterXY, windFloor, windSize;

  $ = jQuery;


  /*
    Update render area
    Update aspect
    Recalc Perspective matrix
   */

  scene = new THREE.Scene;

  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);

  renderer = new THREE.WebGLRenderer({
    antialias: true
  });

  stats = new Stats();

  $((function(_this) {
    return function() {
      $('body').append(renderer.domElement);
      return $('#container').append(stats.dom);
    };
  })(this));

  windSize = new THREE.Vector2();

  windFloor = -250;

  windCenterXY = new THREE.Vector2();

  mouseXY = new THREE.Vector2();

  camXY = new THREE.Vector2();

  onWindResize = function() {
    var h, w;
    w = window.innerWidth;
    h = window.innerHeight;
    windSize.x = w;
    windSize.y = h;
    windCenterXY.x = w / 2;
    windCenterXY.y = h / 2;
    renderer.setSize(w, h);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  };

  onMove = function(event) {
    mouseXY.x = 2 * (event.clientX - windCenterXY.x) / windCenterXY.x;
    mouseXY.y = 2 * (event.clientY - windCenterXY.y) / windCenterXY.y;
  };

  $((function(_this) {
    return function() {
      $(window).resize(function() {
        return onWindResize();
      });
      return $(window).on("mousemove", function(e) {
        return onMove(e);
      });
    };
  })(this));

  init = function() {
    return renderer.setPixelRatio(window.devicePixelRatio);
  };

  updateCameraPosn = function() {
    camera.position.x += (mouseXY.x - camera.position.x) * .05;
    return camera.position.y = THREE.Math.clamp(camera.position.y + (-mouseXY.y - camera.position.y) * .05, -100, 100);
  };

  render = function() {
    updateCameraPosn();
    renderer.render(scene, camera);
    stats.update();
    return requestAnimationFrame(render);
  };

  geometry = new THREE.BoxGeometry(1, 1, 1);

  material = new THREE.MeshBasicMaterial({
    color: 0x00ff00
  });

  cube = new THREE.Mesh(geometry, material);

  scene.add(cube);

  camera.position.z = 1.5;

  onWindResize();

  render();

}).call(this);

//# sourceMappingURL=main.js.map
